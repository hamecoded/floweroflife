<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Flower of Life â€” SVG</title>
<style>
    body {
      margin: 0;
      display: grid;
      place-items: center;
      height: 100svh;
      background: #f7f4ef;
      font-family: Arial, sans-serif;
    }
    .controls {
      position: fixed;
      top: 20px;
      left: 20px;
      background: rgba(255, 255, 255, 0.95);
      padding: 15px;
      border-radius: 8px;
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
      z-index: 1000;
      max-width: 350px;
    }
    .controls h3 {
      margin: 0 0 15px 0;
      color: #333;
      font-size: 16px;
    }
    .control-group {
      margin-bottom: 8px;
    }
    label {
      display: flex;
      align-items: center;
      margin-bottom: 5px;
      font-weight: normal;
      color: #333;
      cursor: pointer;
    }
    label input[type="checkbox"] {
      margin-right: 8px;
      transform: scale(1.2);
    }
    button {
      padding: 5px 10px;
      margin-right: 5px;
      border: 1px solid #ccc;
      background: #f5f5f5;
      border-radius: 4px;
      cursor: pointer;
    }
    button:hover {
      background: #e5e5e5;
    }
    #scaleControl {
      width: 200px;
    }
</style>
</head>

<body>
<div class="controls">
  <h3>Ring Visibility Controls</h3>
    <div id="ringControls"></div>
  <div class="control-group">
      <button id="toggleAll">Toggle All</button>
      <button id="exportSvg">Export SVG</button>
      <button id="animateRings">Animate Rings</button>
  </div>
  <div class="control-group">
    <label>
        <input type="checkbox" id="showVertices" checked>
        Show Vertices
    </label>
        </div>
        <div class="control-group">
          <label for="scaleControl">Scale: <span id="scaleValue">1.0</span></label>
      <input type="range" id="scaleControl" min="0.1" max="3.0" step="0.1" value="1.0">
        </div>
</div>

<div id="app"></div>

<script>
// Live reload - refreshes page when file changes
setInterval(() => {
  fetch(`/?t=${Date.now()}`)
    .then(response => response.text())
    .then(text => {
      const parser = new DOMParser();
      const doc = parser.parseFromString(text, 'text/html');
      const scripts = doc.querySelectorAll('script');
      const currentScripts = document.querySelectorAll('script');
      
      if (scripts.length !== currentScripts.length) {
        location.reload();
        return;
      }
      
      for (let i = 0; i < scripts.length; i++) {
        if (scripts[i].textContent !== currentScripts[i].textContent) {
          location.reload();
          return;
        }
      }
    })
    .catch(() => {});
}, 500);
</script>

<script>
const CONFIG = {
  size: 900,
  r: 36,
  stroke: 2.2,
  colors: [
    "#E31B23",    // red
    "#F36F21",    // orange
    "#FFD21E",    // yellow
    "#3DBB5D",    // green
    "#1E88E5",    // blue
    "#3D3A98",    // indigo
    "#7E57C2"     // violet
  ]
};

function svgEl(tag, attrs) {
  const el = document.createElementNS("http://www.w3.org/2000/svg", tag);
  for(const k in attrs) { el.setAttribute(k, attrs[k]); }
  return el;
}

function circle(cx, cy, r, fillColor, strokeColor, opacity = 1) {
  return svgEl("circle", {
    cx, cy, r,
    fill: fillColor,
    stroke: strokeColor,
    "stroke-width": strokeColor === "none" ? 0 : 2,
    "vector-effect": "non-scaling-stroke",
    opacity: opacity
  });
}

// Find intersection points of two circles
function findCircleIntersections(x1, y1, r1, x2, y2, r2) {
  const d = Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2);
  
  if (d > r1 + r2 || d < Math.abs(r1 - r2) || d === 0) {
    return [];
  }
  
  const a = (r1 ** 2 - r2 ** 2 + d ** 2) / (2 * d);
  const h = Math.sqrt(r1 ** 2 - a ** 2);
  
  const x3 = x1 + a * (x2 - x1) / d;
  const y3 = y1 + a * (y2 - y1) / d;
  
  const x4 = x3 + h * (y2 - y1) / d;
  const y4 = y3 - h * (x2 - x1) / d;
  
  const x5 = x3 - h * (y2 - y1) / d;
  const y5 = y3 + h * (x2 - x1) / d;
  
  return [[x4, y4], [x5, y5]];
}

// Ring Generation Functions

function genRing(ringIndex, cx, cy, r, stroke, color, referenceCircle, previousArc = null, globalUsedPositions = null, allRings = []) {
  const group = svgEl("g", {});
  const circles = [];
  const vertices = [];
  const usedPositions = globalUsedPositions || new Set();
  
  // Check if this ring should be visible
  const isVisible = document.getElementById(`ring${ringIndex}`)?.checked ?? true;
  const baseOpacity = Math.max(0.1, 1 - (ringIndex * 0.1));
  group.setAttribute('opacity', isVisible ? 1 : 0);
  
  if (ringIndex === 0) {
    // First ring: Single center circle with red dot
    group.appendChild(circle(cx, cy, r, "none", "black", baseOpacity));
    circles.push({x: cx, y: cy, r: r, id: "center"});
    usedPositions.add(`${cx.toFixed(3)},${cy.toFixed(3)}`);
    vertices.push(circle(cx, cy, 3, "red", "red", isVisible ? 1 : 0));
    
  } else if (ringIndex === 1) {
    // Second ring: Start from topmost point of reference circle, then clockwise intersections
    const startX = cx;
    const startY = cy - r;
    
    group.appendChild(circle(startX, startY, r, "none", "black", baseOpacity));
    circles.push({x: startX, y: startY, r: r, id: `ring1_0`});
    usedPositions.add(`${startX.toFixed(3)},${startY.toFixed(3)}`);
    
    let currentX = startX;
    let currentY = startY;
    let circleId = 1;
    
    while (true) {
      const intersections = findCircleIntersections(
        currentX, currentY, r,
        referenceCircle.x, referenceCircle.y, referenceCircle.r
      );
      
      let nextIntersection = null;
      for (const [ix, iy] of intersections) {
        const key = `${ix.toFixed(3)},${iy.toFixed(3)}`;
        if (!usedPositions.has(key)) {
          const currentAngle = Math.atan2(currentY - referenceCircle.y, currentX - referenceCircle.x);
          const intersectionAngle = Math.atan2(iy - referenceCircle.y, ix - referenceCircle.x);
          const angleDiff = ((intersectionAngle - currentAngle + Math.PI * 2) % (Math.PI * 2));
          
          if (angleDiff > 0 && angleDiff < Math.PI) {
            nextIntersection = [ix, iy];
            break;
          }
        }
      }
      
      if (!nextIntersection) break;
      
      const [ix, iy] = nextIntersection;
      const key = `${ix.toFixed(3)},${iy.toFixed(3)}`;
      
      if (usedPositions.has(key)) break;
      
      group.appendChild(circle(ix, iy, r, "none", "black", baseOpacity));
      circles.push({x: ix, y: iy, r: r, id: `ring1_${circleId++}`});
      usedPositions.add(key);
      currentX = ix;
      currentY = iy;
    }
    
    // Add vertices ONLY at the center of circles that were actually drawn for this ring
    if (color && color !== "none") {
      for (const circleData of circles) {
        vertices.push(circle(circleData.x, circleData.y, 3, color, color, 1));
      }
    }
    
  } else {
    // Third ring and onwards: Find new intersection points between circles from all previous rings
    if (allRings.length < 2) return { group, circles, arc: null, vertices: [] };
    
    let circleId = 0;
    const newIntersectionPoints = [];
    
    const circlesToCheck = ringIndex <= 3 ? allRings[allRings.length - 1] : allRings.flat();
    
    // First pass: Find intersections between circles from previous rings
    for (let i = 0; i < circlesToCheck.length; i++) {
      for (let j = i + 1; j < circlesToCheck.length; j++) {
        const intersections = findCircleIntersections(
          circlesToCheck[i].x, circlesToCheck[i].y, circlesToCheck[i].r,
          circlesToCheck[j].x, circlesToCheck[j].y, circlesToCheck[j].r
        );
        
        for (const [ix, iy] of intersections) {
          const key = `${ix.toFixed(3)},${iy.toFixed(3)}`;
          if (!usedPositions.has(key)) {
            newIntersectionPoints.push([ix, iy]);
          }
        }
      }
    }
    
    // Draw main circles from first pass intersections
    for (const [ix, iy] of newIntersectionPoints) {
      const key = `${ix.toFixed(3)},${iy.toFixed(3)}`;
      
      if (usedPositions.has(key)) continue;
      
      group.appendChild(circle(ix, iy, r, "none", "black", baseOpacity));
      circles.push({x: ix, y: iy, r: r, id: `ring${ringIndex}_${circleId++}`});
      usedPositions.add(key);
    }
    
    // Secondary check: Enhanced geometric complexity for Ring 4+
    if (ringIndex >= 4) {
      const secondaryIntersectionPoints = [];
      
      // Check intersections between new and previous circles
      for (let i = 0; i < circles.length; i++) {
        for (let j = 0; j < circlesToCheck.length; j++) {
          const intersections = findCircleIntersections(
            circles[i].x, circles[i].y, circles[i].r,
            circlesToCheck[j].x, circlesToCheck[j].y, circlesToCheck[j].r
          );

          for (const [ix, iy] of intersections) {
            const key = `${ix.toFixed(3)},${iy.toFixed(3)}`;
            if (!usedPositions.has(key)) {
              secondaryIntersectionPoints.push([ix, iy]);
            }
          }
        }
      }

      // Draw additional circles from secondary intersections
      for (const [ix, iy] of secondaryIntersectionPoints) {
        const key = `${ix.toFixed(3)},${iy.toFixed(3)}`;

        if (usedPositions.has(key)) continue;

        group.appendChild(circle(ix, iy, r, "none", "black", baseOpacity));
        circles.push({x: ix, y: iy, r: r, id: `ring${ringIndex}_secondary_${circleId++}`});
        usedPositions.add(key);
      }
    }
    
    // Add vertices ONLY at the center of circles that were actually drawn for this ring
    if (color && color !== "none") {
      for (const circleData of circles) {
        vertices.push(circle(circleData.x, circleData.y, 3, color, color, 1));
      }
    }
  }
  
  // Calculate outer boundary arc
  let arc = null;
  if (circles.length > 0) {
    arc = calculateOuterBoundaryArc(circles, referenceCircle);
  }
  
  // Update the count display
  const countElement = document.getElementById(`ring${ringIndex}Count`);
  if(countElement) {
    countElement.textContent = circles.length;
  }
  
  return { group, circles, arc, vertices };
}

function calculateOuterBoundaryArc(circles, referenceCircle) {
  if (circles.length === 0) return null;
  
  let maxDistance = 0;
  let farthestCircle = circles[0];
  
  for (const circle of circles) {
    const distance = Math.sqrt(
      (circle.x - referenceCircle.x) ** 2 + (circle.y - referenceCircle.y) ** 2
    );
    if (distance > maxDistance) {
      maxDistance = distance;
      farthestCircle = circle;
    }
  }
  
  const intersectionPoints = [];
  const usedPoints = new Set();
  
  for (let i = 0; i < circles.length; i++) {
    for (let j = i + 1; j < circles.length; j++) {
      const intersections = findCircleIntersections(
        circles[i].x, circles[i].y, circles[i].r,
        circles[j].x, circles[j].y, circles[j].r
      );
      
      for (const [ix, iy] of intersections) {
        const key = `${ix.toFixed(3)},${iy.toFixed(3)}`;
        if (!usedPoints.has(key)) {
          usedPoints.add(key);
          intersectionPoints.push([ix, iy]);
        }
      }
    }
  }
  
  return {
    center: referenceCircle,
    radius: maxDistance + circles[0].r,
    intersectionPoints: intersectionPoints
  };
}

// Main Fruit Generation

function genFruit(cx, cy, r, stroke, colors, svgElement = null) {
  const referenceCircle = {x: cx, y: cy, r: r};
  let previousArc = null;
  let totalCircles = 0;
  const globalUsedPositions = new Set();
  const allRings = [];
  const allVertices = [];
  
  // Generate rings for each available color
  for(let ringIndex = 0; ringIndex < colors.length; ringIndex++) {
    const color = colors[ringIndex];
    const { group, circles, arc, vertices } = genRing(ringIndex, cx, cy, r, stroke, color, referenceCircle, previousArc, globalUsedPositions, allRings);
    
    if (svgElement) {
      svgElement.appendChild(group);
    }
    
    allRings.push(circles);
    if (vertices) {
      allVertices.push(...vertices);
    }
    previousArc = arc;
    totalCircles += circles.length;
  }
  
  // Create vertex layer on top
  if (svgElement && allVertices.length > 0) {
    const vertexGroup = svgEl("g", { id: "vertex-layer" });
    for (const vertex of allVertices) {
      vertexGroup.appendChild(vertex);
    }
    svgElement.appendChild(vertexGroup);
  }
  
  return totalCircles;
}

// Initialization & Setup

function generateRingControls() {
  const ringControls = document.getElementById('ringControls');
  ringControls.innerHTML = '';
  
  // Add rings for each color
  CONFIG.colors.forEach((color, index) => {
    const ringIndex = index;
    const ringLabels = ['Source', 'Seed(Heart)', 'Subconscious', 'Egg(Body)', 'Flower(Consciousness)', 'Soul', 'Fruit(Reality)'];
    const colorNames = ['Red', 'Orange', 'Yellow', 'Green', 'Blue', 'Indigo', 'Violet'];
    const ringLabel = ringLabels[index] || `Ring${ringIndex}`;
    const colorName = colorNames[index] || color;
    
    const controlGroup = document.createElement('div');
    controlGroup.className = 'control-group';
    controlGroup.innerHTML = `
      <label>
        <input type="checkbox" id="ring${ringIndex}" checked>
        ${ringLabel} - <span id="ring${ringIndex}Count">0</span> circles - <span style="color: ${color};">${colorName}</span>
      </label>
    `;
    ringControls.appendChild(controlGroup);
  });
}

function initFlowerOfLife() {
  const W = CONFIG.size, H = CONFIG.size, cx = W/2, cy = H/2;
  
  const svg = svgEl("svg", {
    viewBox: `0 0 ${W} ${H}`,
    width: W,
    height: H
  });

  const totalCircles = genFruit(cx, cy, CONFIG.r, CONFIG.stroke, CONFIG.colors, svg);
  
  const appElement = document.getElementById("app");
  appElement.appendChild(svg);
}

// Add a single ring incrementally
function addRingIncremental(ringIndex, cx, cy, r, stroke, colors, referenceCircle, previousArc, svgElement, globalUsedPositions, allRings) {
  const color = colors[ringIndex];
  const { group, circles, arc, vertices } = genRing(ringIndex, cx, cy, r, stroke, color, referenceCircle, previousArc, globalUsedPositions, allRings);
  
  svgElement.appendChild(group);
  
  if (vertices && vertices.length > 0) {
    let vertexGroup = svgElement.querySelector('#vertex-layer');
    if (!vertexGroup) {
      vertexGroup = svgEl("g", { id: "vertex-layer" });
      svgElement.appendChild(vertexGroup);
    }
    for (const vertex of vertices) {
      vertexGroup.appendChild(vertex);
    }
    
    // Ensure vertex layer is on top
    svgElement.appendChild(vertexGroup);
  }
  
  return { group, circles, arc };
}

// UI Controls & Interactions

function ensureVertexLayerOnTop() {
  const svg = document.querySelector('#app svg');
  if (!svg) return;
  
  const vertexGroup = svg.querySelector('#vertex-layer');
  if (vertexGroup) {
    // Move vertex layer to the end to ensure it's on top
    svg.appendChild(vertexGroup);
  }
}

function updateVertexVisibility() {
  const showVerticesCheckbox = document.getElementById('showVertices');
  const svg = document.querySelector('#app svg');
  if (!svg || !showVerticesCheckbox) return;
  
  ensureVertexLayerOnTop();
  
  const vertexGroup = svg.querySelector('#vertex-layer');
  if (vertexGroup) {
    const vertices = vertexGroup.querySelectorAll('circle');
    const showVertices = showVerticesCheckbox.checked;
    
    vertices.forEach(vertex => {
      const fillColor = vertex.getAttribute('fill');
      let ringIndex = -1;
      
      // Map colors to ring indices
      if (fillColor === "red") {
        ringIndex = 0;
      } else {
        for (let i = 0; i < CONFIG.colors.length; i++) {
          if (fillColor === CONFIG.colors[i]) {
            ringIndex = i;
            break;
          }
        }
      }
      
      if (ringIndex >= 0) {
        const ringCheckbox = document.getElementById(`ring${ringIndex}`);
        if (ringCheckbox) {
          // Show vertex if both controls are checked
          vertex.setAttribute('opacity', (showVertices && ringCheckbox.checked) ? 1 : 0);
        }
      }
    });
  }
}

function updateRingVisibility() {
  const svg = document.querySelector('#app svg');
  if (!svg) return;
  
  // Ensure vertex layer is on top
  ensureVertexLayerOnTop();
  
  // Control ring groups visibility
  const ringGroups = svg.querySelectorAll('g:not(#vertex-layer)');
  ringGroups.forEach((group, index) => {
    const checkbox = document.getElementById(`ring${index}`);
    if(checkbox) {
      group.setAttribute('opacity', checkbox.checked ? 1 : 0);
    }
  });
  
  // Update vertex visibility
  updateVertexVisibility();
}

function updateScale() {
  const scaleValue = document.getElementById('scaleControl').value;
  const scaleDisplay = document.getElementById('scaleValue');
  const svg = document.querySelector('#app svg');
  
  if (scaleDisplay) {
    scaleDisplay.textContent = parseFloat(scaleValue).toFixed(1);
  }
  
  if (svg) {
    const transform = `scale(${scaleValue})`;
    svg.style.transform = transform;
    svg.style.transformOrigin = 'center center';
  }
}

function addRingsIncrementally() {
  const svg = document.querySelector('#app svg');
  if (!svg) return;
  
  svg.innerHTML = '';
  
  const W = CONFIG.size, H = CONFIG.size, cx = W/2, cy = H/2;
  const referenceCircle = {x: cx, y: cy, r: CONFIG.r};
  let previousArc = null;
  const globalUsedPositions = new Set();
  const allRings = [];
  const totalRings = CONFIG.colors.length - 1;
  
  for(let ringIndex = 0; ringIndex <= totalRings; ringIndex++) {
    setTimeout(() => {
      const result = addRingIncremental(ringIndex, cx, cy, CONFIG.r, CONFIG.stroke, CONFIG.colors, referenceCircle, previousArc, svg, globalUsedPositions, allRings);
      previousArc = result.arc;
      allRings.push(result.circles);
      
      const checkbox = document.getElementById(`ring${ringIndex}`);
      if(checkbox) {
        result.group.setAttribute('opacity', checkbox.checked ? 1 : 0);
      }
      
      // Update vertex visibility
      updateVertexVisibility();
    }, ringIndex * 500);
  }
}

function setupEventListeners() {
  const totalRings = CONFIG.colors.length - 1;
  
  // Show Vertices checkbox
  const showVerticesCheckbox = document.getElementById('showVertices');
  if(showVerticesCheckbox) {
    showVerticesCheckbox.addEventListener('change', updateVertexVisibility);
  }

  // Ring checkboxes
  for(let i = 0; i <= totalRings; i++) {
    const checkbox = document.getElementById(`ring${i}`);
    if(checkbox) {
      checkbox.addEventListener('change', updateRingVisibility);
    }
  }

  // Toggle All button
  document.getElementById('toggleAll').addEventListener('click', () => {
    // Check if any rings are visible
    let anyVisible = false;
    for(let i = 0; i <= totalRings; i++) {
      const checkbox = document.getElementById(`ring${i}`);
      if(checkbox && checkbox.checked) {
        anyVisible = true;
        break;
      }
    }
    
    // Toggle all rings
    const newState = !anyVisible;
    for(let i = 0; i <= totalRings; i++) {
      const checkbox = document.getElementById(`ring${i}`);
      if(checkbox) checkbox.checked = newState;
    }
    updateRingVisibility();
  });
  
  // Animate Rings button
  document.getElementById('animateRings').addEventListener('click', addRingsIncrementally);
  
  // Scale control
  const scaleControl = document.getElementById('scaleControl');
  if (scaleControl) {
    scaleControl.addEventListener('input', updateScale);
  }
  
  // Export SVG button
  document.getElementById('exportSvg').addEventListener('click', exportToSVG);
}


function exportToSVG() {
  const svg = document.querySelector('#app svg');
  if (!svg) {
    alert('No SVG found to export');
    return;
  }
  
  // Clone the SVG
  const svgClone = svg.cloneNode(true);
  
  // Get the current scale
  const scaleControl = document.getElementById('scaleControl');
  const scale = scaleControl ? parseFloat(scaleControl.value) : 1.0;
  
  // Calculate bounds of visible content
  let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
  const circles = svgClone.querySelectorAll('circle');
  
  circles.forEach(circle => {
    const cx = parseFloat(circle.getAttribute('cx'));
    const cy = parseFloat(circle.getAttribute('cy'));
    const r = parseFloat(circle.getAttribute('r'));
    
    // Only consider visible circles
    const opacity = parseFloat(circle.getAttribute('opacity') || '1');
    if (opacity > 0) {
      minX = Math.min(minX, cx - r);
      minY = Math.min(minY, cy - r);
      maxX = Math.max(maxX, cx + r);
      maxY = Math.max(maxY, cy + r);
    }
  });
  
  // Add padding around content
  const padding = 20;
  minX -= padding;
  minY -= padding;
  maxX += padding;
  maxY += padding;
  
  // Calculate dimensions
  const width = maxX - minX;
  const height = maxY - minY;
  
  // Create scalable SVG
  svgClone.setAttribute('width', '100%');
  svgClone.setAttribute('height', '100%');
  svgClone.setAttribute('viewBox', `${minX} ${minY} ${width} ${height}`);
  svgClone.setAttribute('preserveAspectRatio', 'xMidYMid meet');
  svgClone.setAttribute('xmlns', 'http://www.w3.org/2000/svg');
  svgClone.setAttribute('xmlns:xlink', 'http://www.w3.org/1999/xlink');
  svgClone.setAttribute('fill', 'none');
  svgClone.setAttribute('background', 'transparent');
  
  // Remove width/height from groups
  const allGroups = svgClone.querySelectorAll('g');
  allGroups.forEach(group => {
    group.removeAttribute('width');
    group.removeAttribute('height');
  });
  
  // Ensure stroke widths are scalable
  const allCircles = svgClone.querySelectorAll('circle');
  allCircles.forEach(circle => {
    const strokeWidth = parseFloat(circle.getAttribute('stroke-width') || '2');
    // Use relative stroke width
    circle.setAttribute('stroke-width', strokeWidth);
    // Ensure stroke scales with element
    circle.setAttribute('vector-effect', 'non-scaling-stroke');
  });
  
  // Convert to string
  const svgString = new XMLSerializer().serializeToString(svgClone);
  
  // Create and download file
  const blob = new Blob([svgString], { type: 'image/svg+xml' });
  const url = URL.createObjectURL(blob);
  
  const link = document.createElement('a');
  link.href = url;
  link.download = `flower-of-life-${new Date().toISOString().slice(0, 10)}.svg`;
  document.body.appendChild(link);
  link.click();
  document.body.removeChild(link);
  
  URL.revokeObjectURL(url);
}

function initializeApp() {
  try {
    generateRingControls();
    initFlowerOfLife();
    setupEventListeners();
  } catch (error) {
    console.error('Initialization error:', error);
  }
}

if (document.readyState === 'loading') {
  document.addEventListener('DOMContentLoaded', initializeApp);
} else {
  initializeApp();
}
</script>
</body>
</html>