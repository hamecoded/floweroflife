<!doctype html>
<meta charset="utf-8" />
<title>Flower of Life â€” SVG</title>
<style>
  body{margin:0;display:grid;place-items:center;height:100svh;background:#f7f4ef;font-family:Arial,sans-serif}
  .controls{position:fixed;top:20px;left:20px;background:rgba(255,255,255,0.95);padding:15px;border-radius:8px;box-shadow:0 2px 10px rgba(0,0,0,0.1);z-index:1000;max-width:250px}
  .controls h3{margin:0 0 15px 0;color:#333;font-size:16px}
  .control-group{margin-bottom:8px}
  label{display:flex;align-items:center;margin-bottom:5px;font-weight:normal;color:#333;cursor:pointer}
  label input[type="checkbox"]{margin-right:8px;transform:scale(1.2)}
  button{padding:5px 10px;margin-right:5px;border:1px solid #ccc;background:#f5f5f5;border-radius:4px;cursor:pointer}
  button:hover{background:#e5e5e5}
</style>

<div class="controls">
  <h3>Ring Visibility Controls</h3>
  <div class="control-group">
    <label>
      <input type="checkbox" id="ring0" checked>
      Ring 0 (Center) - <span id="ring0Count">1</span> circles - <span style="color: red;">Red</span>
    </label>
  </div>
  <div class="control-group">
    <label>
      <input type="checkbox" id="ring1" checked>
      Ring 1 - <span id="ring1Count">6</span> circles - <span style="color: orange;">Orange</span>
    </label>
  </div>
  <div class="control-group">
    <label>
      <input type="checkbox" id="ring2" checked>
      Ring 2 - <span id="ring2Count">0</span> circles - <span style="color: yellow;">Yellow</span>
    </label>
  </div>
  <div class="control-group">
    <label>
      <input type="checkbox" id="ring3" checked>
      Ring 3 - <span id="ring3Count">0</span> circles - <span style="color: green;">Green</span>
    </label>
  </div>
  <div class="control-group">
    <label>
      <input type="checkbox" id="ring4" checked>
      Ring 4 - <span id="ring4Count">0</span> circles - <span style="color: blue;">Blue</span>
    </label>
  </div>
  <div class="control-group">
    <label>
      <input type="checkbox" id="ring5" checked>
      Ring 5 - <span id="ring5Count">0</span> circles - <span style="color: indigo;">Indigo</span>
    </label>
  </div>
  <div class="control-group">
    <label>
      <input type="checkbox" id="ring6" checked>
      Ring 6 - <span id="ring6Count">0</span> circles - <span style="color: violet;">Violet</span>
    </label>
  </div>
  <div class="control-group">
    <label>
      <input type="checkbox" id="ring7" checked>
      Ring 7 - <span id="ring7Count">0</span> circles - <span style="color: #999;">No Color</span>
    </label>
  </div>
  <div class="control-group">
    <label>
      <input type="checkbox" id="ring8" checked>
      Ring 8 - <span id="ring8Count">0</span> circles - <span style="color: #999;">No Color</span>
    </label>
  </div>
  <div class="control-group">
    <button id="showAll">Show All</button>
    <button id="hideAll">Hide All</button>
  </div>
  <div class="control-group">
    <label for="scaleControl">Scale: <span id="scaleValue">1.0</span></label>
    <input type="range" id="scaleControl" min="0.1" max="3.0" step="0.1" value="1.0" style="width: 200px;">
  </div>
</div>

<div id="app"></div>

<script>
// Live reload - refreshes page when file changes
setInterval(() => {
  fetch(`/?t=${Date.now()}`)
    .then(response => response.text())
    .then(text => {
      const parser = new DOMParser();
      const doc = parser.parseFromString(text, 'text/html');
      const scripts = doc.querySelectorAll('script');
      const currentScripts = document.querySelectorAll('script');
      
      if (scripts.length !== currentScripts.length) {
        location.reload();
        return;
      }
      
      for (let i = 0; i < scripts.length; i++) {
        if (scripts[i].textContent !== currentScripts[i].textContent) {
          location.reload();
          return;
        }
      }
    })
    .catch(() => {});
}, 500);
</script>

<script>
// ============================================================================
// CONFIGURATION & CONSTANTS
// ============================================================================

const CONFIG = {
  size: 900,
  r: 36,
  stroke: 2.2,
  colors: [
    "#E31B23",    // red
    "#F36F21",    // orange
    "#FFD21E",    // yellow
    "#3DBB5D",    // green
    "#1E88E5",    // blue
    "#3D3A98",    // indigo
    "#7E57C2"     // violet
  ]
};

// ============================================================================
// HELPER FUNCTIONS
// ============================================================================

function svgEl(tag, attrs) {
  const el = document.createElementNS("http://www.w3.org/2000/svg", tag);
  for(const k in attrs) { el.setAttribute(k, attrs[k]); }
  return el;
}

function circle(cx, cy, r, fillColor, strokeColor, opacity = 1) {
  return svgEl("circle", {
    cx, cy, r,
    fill: fillColor,
    stroke: strokeColor,
    "stroke-width": strokeColor === "none" ? 0 : 2,
    "vector-effect": "non-scaling-stroke",
    opacity: opacity
  });
}

// Find intersection points of two circles
function findCircleIntersections(x1, y1, r1, x2, y2, r2) {
  const d = Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2);
  
  if (d > r1 + r2 || d < Math.abs(r1 - r2) || d === 0) {
    return [];
  }
  
  const a = (r1 ** 2 - r2 ** 2 + d ** 2) / (2 * d);
  const h = Math.sqrt(r1 ** 2 - a ** 2);
  
  const x3 = x1 + a * (x2 - x1) / d;
  const y3 = y1 + a * (y2 - y1) / d;
  
  const x4 = x3 + h * (y2 - y1) / d;
  const y4 = y3 - h * (x2 - x1) / d;
  
  const x5 = x3 - h * (y2 - y1) / d;
  const y5 = y3 + h * (x2 - x1) / d;
  
  return [[x4, y4], [x5, y5]];
}

// ============================================================================
// RING GENERATION FUNCTIONS
// ============================================================================

function genRing(ringIndex, cx, cy, r, stroke, color, referenceCircle, previousArc = null, globalUsedPositions = null, allRings = []) {
  const group = svgEl("g", {});
  const circles = [];
  const vertices = [];
  const usedPositions = globalUsedPositions || new Set();
  
  // Check if this ring should be visible
  const isVisible = document.getElementById(`ring${ringIndex}`)?.checked ?? true;
  const baseOpacity = Math.max(0.1, 1 - (ringIndex * 0.1));
  group.setAttribute('opacity', isVisible ? 1 : 0);
  
  if (ringIndex === 0) {
    // First ring: Single center circle with red dot
    group.appendChild(circle(cx, cy, r, "none", "black", baseOpacity));
    circles.push({x: cx, y: cy, r: r, id: "center"});
    usedPositions.add(`${cx.toFixed(3)},${cy.toFixed(3)}`);
    vertices.push(circle(cx, cy, 3, "red", "red", 1));
    
  } else if (ringIndex === 1) {
    // Second ring: Start from topmost point of reference circle, then clockwise intersections
    const startX = cx;
    const startY = cy - r;
    
    group.appendChild(circle(startX, startY, r, "none", "black", baseOpacity));
    circles.push({x: startX, y: startY, r: r, id: `ring1_0`});
    usedPositions.add(`${startX.toFixed(3)},${startY.toFixed(3)}`);
    
    let currentX = startX;
    let currentY = startY;
    let circleId = 1;
    const vertexPositions = [[startX, startY]];
    
    while (true) {
      const intersections = findCircleIntersections(
        currentX, currentY, r,
        referenceCircle.x, referenceCircle.y, referenceCircle.r
      );
      
      let nextIntersection = null;
      for (const [ix, iy] of intersections) {
        const key = `${ix.toFixed(3)},${iy.toFixed(3)}`;
        if (!usedPositions.has(key)) {
          const currentAngle = Math.atan2(currentY - referenceCircle.y, currentX - referenceCircle.x);
          const intersectionAngle = Math.atan2(iy - referenceCircle.y, ix - referenceCircle.x);
          const angleDiff = ((intersectionAngle - currentAngle + Math.PI * 2) % (Math.PI * 2));
          
          if (angleDiff > 0 && angleDiff < Math.PI) {
            nextIntersection = [ix, iy];
            break;
          }
        }
      }
      
      if (!nextIntersection) break;
      
      const [ix, iy] = nextIntersection;
      const key = `${ix.toFixed(3)},${iy.toFixed(3)}`;
      
      if (usedPositions.has(key)) break;
      
      group.appendChild(circle(ix, iy, r, "none", "black", baseOpacity));
      circles.push({x: ix, y: iy, r: r, id: `ring1_${circleId++}`});
      usedPositions.add(key);
      vertexPositions.push([ix, iy]);
      currentX = ix;
      currentY = iy;
    }
    
    if (color && color !== "none") {
      for (const [vx, vy] of vertexPositions) {
        vertices.push(circle(vx, vy, 3, color, color, 1));
      }
    }
    
  } else {
    // Third ring and onwards: Find new intersection points between circles from all previous rings
    if (allRings.length < 2) return { group, circles, arc: null, vertices: [] };
    
    let circleId = 0;
    const newIntersectionPoints = [];
    
    const circlesToCheck = ringIndex <= 3 ? allRings[allRings.length - 1] : allRings.flat();
    
    for (let i = 0; i < circlesToCheck.length; i++) {
      for (let j = i + 1; j < circlesToCheck.length; j++) {
        const intersections = findCircleIntersections(
          circlesToCheck[i].x, circlesToCheck[i].y, circlesToCheck[i].r,
          circlesToCheck[j].x, circlesToCheck[j].y, circlesToCheck[j].r
        );
        
        for (const [ix, iy] of intersections) {
          const key = `${ix.toFixed(3)},${iy.toFixed(3)}`;
          if (!usedPositions.has(key)) {
            newIntersectionPoints.push([ix, iy]);
          }
        }
      }
    }
    
    const vertexPositions = [];
    for (const [ix, iy] of newIntersectionPoints) {
      const key = `${ix.toFixed(3)},${iy.toFixed(3)}`;
      
      if (usedPositions.has(key)) continue;
      
      group.appendChild(circle(ix, iy, r, "none", "black", baseOpacity));
      circles.push({x: ix, y: iy, r: r, id: `ring${ringIndex}_${circleId++}`});
      usedPositions.add(key);
      vertexPositions.push([ix, iy]);
    }
    
    if (color && color !== "none") {
      for (const [vx, vy] of vertexPositions) {
        vertices.push(circle(vx, vy, 3, color, color, 1));
      }
    }
  }
  
  // Calculate outer boundary arc
  let arc = null;
  if (circles.length > 0) {
    arc = calculateOuterBoundaryArc(circles, referenceCircle);
  }
  
  // Update the count display
  const countElement = document.getElementById(`ring${ringIndex}Count`);
  if(countElement) {
    countElement.textContent = circles.length;
  }
  
  return { group, circles, arc, vertices };
}

function calculateOuterBoundaryArc(circles, referenceCircle) {
  if (circles.length === 0) return null;
  
  let maxDistance = 0;
  let farthestCircle = circles[0];
  
  for (const circle of circles) {
    const distance = Math.sqrt(
      (circle.x - referenceCircle.x) ** 2 + (circle.y - referenceCircle.y) ** 2
    );
    if (distance > maxDistance) {
      maxDistance = distance;
      farthestCircle = circle;
    }
  }
  
  const intersectionPoints = [];
  const usedPoints = new Set();
  
  for (let i = 0; i < circles.length; i++) {
    for (let j = i + 1; j < circles.length; j++) {
      const intersections = findCircleIntersections(
        circles[i].x, circles[i].y, circles[i].r,
        circles[j].x, circles[j].y, circles[j].r
      );
      
      for (const [ix, iy] of intersections) {
        const key = `${ix.toFixed(3)},${iy.toFixed(3)}`;
        if (!usedPoints.has(key)) {
          usedPoints.add(key);
          intersectionPoints.push([ix, iy]);
        }
      }
    }
  }
  
  return {
    center: referenceCircle,
    radius: maxDistance + circles[0].r,
    intersectionPoints: intersectionPoints
  };
}

// ============================================================================
// MAIN FRUIT GENERATION
// ============================================================================

function genFruit(cx, cy, r, stroke, colors, svgElement = null) {
  const referenceCircle = {x: cx, y: cy, r: r};
  let previousArc = null;
  let totalCircles = 0;
  const globalUsedPositions = new Set();
  const allRings = [];
  const allVertices = [];
  
  // Generate 9 rings (0-8) using genRing function
  for(let ringIndex = 0; ringIndex < 9; ringIndex++) {
    const color = ringIndex < colors.length ? colors[ringIndex] : "none";
    const { group, circles, arc, vertices } = genRing(ringIndex, cx, cy, r, stroke, color, referenceCircle, previousArc, globalUsedPositions, allRings);
    
    if (svgElement) {
      svgElement.appendChild(group);
    }
    
    allRings.push(circles);
    if (vertices) {
      allVertices.push(...vertices);
    }
    previousArc = arc;
    totalCircles += circles.length;
  }
  
  // Create a separate vertex layer on top of all circles
  if (svgElement && allVertices.length > 0) {
    const vertexGroup = svgEl("g", { id: "vertex-layer" });
    for (const vertex of allVertices) {
      vertexGroup.appendChild(vertex);
    }
    svgElement.appendChild(vertexGroup);
  }
  
  return totalCircles;
}

// ============================================================================
// INITIALIZATION & SETUP
// ============================================================================

function initFlowerOfLife() {
  const W = CONFIG.size, H = CONFIG.size, cx = W/2, cy = H/2;
  
  const svg = svgEl("svg", {
    viewBox: `0 0 ${W} ${H}`,
    width: W,
    height: H
  });

  const totalCircles = genFruit(cx, cy, CONFIG.r, CONFIG.stroke, CONFIG.colors, svg);
  
  const appElement = document.getElementById("app");
  appElement.appendChild(svg);
}

// Add a single ring incrementally
function addRingIncremental(ringIndex, cx, cy, r, stroke, colors, referenceCircle, previousArc, svgElement, globalUsedPositions, allRings) {
  const color = colors[ringIndex % colors.length];
  const { group, circles, arc, vertices } = genRing(ringIndex, cx, cy, r, stroke, color, referenceCircle, previousArc, globalUsedPositions, allRings);
  
  svgElement.appendChild(group);
  
  if (vertices && vertices.length > 0) {
    let vertexGroup = svgElement.querySelector('#vertex-layer');
    if (!vertexGroup) {
      vertexGroup = svgEl("g", { id: "vertex-layer" });
      svgElement.appendChild(vertexGroup);
    }
    for (const vertex of vertices) {
      vertexGroup.appendChild(vertex);
    }
  }
  
  return { group, circles, arc };
}

// ============================================================================
// UI CONTROLS & INTERACTIONS
// ============================================================================

function updateRingVisibility() {
  const groups = document.querySelectorAll('#app svg g');
  const vertexGroup = document.querySelector('#app svg #vertex-layer');
  
  // Control ring groups visibility
  groups.forEach((group, index) => {
    const checkbox = document.getElementById(`ring${index}`);
    if(checkbox) {
      group.setAttribute('opacity', checkbox.checked ? 1 : 0);
    }
  });
  
  // Control vertex visibility based on ring checkboxes
  if (vertexGroup) {
    const vertices = vertexGroup.querySelectorAll('circle');
    vertices.forEach(vertex => {
      const fillColor = vertex.getAttribute('fill');
      let ringIndex = -1;
      
      const colorToRing = {
        'red': 0, '#E31B23': 0,
        'orange': 1, '#F36F21': 1,
        'yellow': 2, '#FFD21E': 2,
        'green': 3, '#3DBB5D': 3,
        'blue': 4, '#1E88E5': 4,
        'indigo': 5, '#3D3A98': 5,
        'violet': 6, '#7E57C2': 6
      };
      
      ringIndex = colorToRing[fillColor] || -1;
      
      if (ringIndex >= 0) {
        const checkbox = document.getElementById(`ring${ringIndex}`);
        if (checkbox) {
          vertex.setAttribute('opacity', checkbox.checked ? 1 : 0);
        }
      }
    });
  }
}

function updateScale() {
  const scaleValue = document.getElementById('scaleControl').value;
  const scaleDisplay = document.getElementById('scaleValue');
  const svg = document.querySelector('#app svg');
  
  if (scaleDisplay) {
    scaleDisplay.textContent = parseFloat(scaleValue).toFixed(1);
  }
  
  if (svg) {
    const transform = `scale(${scaleValue})`;
    svg.style.transform = transform;
    svg.style.transformOrigin = 'center center';
  }
}

function addRingsIncrementally() {
  const svg = document.querySelector('#app svg');
  if (!svg) return;
  
  svg.innerHTML = '';
  
  const W = CONFIG.size, H = CONFIG.size, cx = W/2, cy = H/2;
  const referenceCircle = {x: cx, y: cy, r: CONFIG.r};
  let previousArc = null;
  const globalUsedPositions = new Set();
  const allRings = [];
  
  for(let ringIndex = 0; ringIndex < 9; ringIndex++) {
    setTimeout(() => {
      const result = addRingIncremental(ringIndex, cx, cy, CONFIG.r, CONFIG.stroke, CONFIG.colors, referenceCircle, previousArc, svg, globalUsedPositions, allRings);
      previousArc = result.arc;
      allRings.push(result.circles);
      
      const checkbox = document.getElementById(`ring${ringIndex}`);
      if(checkbox) {
        result.group.setAttribute('opacity', checkbox.checked ? 1 : 0);
      }
      
      const vertexGroup = svg.querySelector('#vertex-layer');
      if(vertexGroup) {
        const vertices = vertexGroup.querySelectorAll('circle');
        vertices.forEach(vertex => {
          const fillColor = vertex.getAttribute('fill');
          const colorToRing = {
            'red': 0, '#E31B23': 0,
            'orange': 1, '#F36F21': 1,
            'yellow': 2, '#FFD21E': 2,
            'green': 3, '#3DBB5D': 3,
            'blue': 4, '#1E88E5': 4,
            'indigo': 5, '#3D3A98': 5,
            'violet': 6, '#7E57C2': 6
          };
          const vertexRingIndex = colorToRing[fillColor] || -1;
          if (vertexRingIndex === ringIndex) {
            const ringCheckbox = document.getElementById(`ring${ringIndex}`);
            if(ringCheckbox) {
              vertex.setAttribute('opacity', ringCheckbox.checked ? 1 : 0);
            }
          }
        });
      }
    }, ringIndex * 500);
  }
}

function setupEventListeners() {
  // Ring checkboxes
  for(let i = 0; i < 9; i++) {
    const checkbox = document.getElementById(`ring${i}`);
    if(checkbox) {
      checkbox.addEventListener('change', updateRingVisibility);
    }
  }

  // Show All button
  document.getElementById('showAll').addEventListener('click', () => {
    for(let i = 0; i < 9; i++) {
      const checkbox = document.getElementById(`ring${i}`);
      if(checkbox) checkbox.checked = true;
    }
    updateRingVisibility();
  });

  // Hide All button
  document.getElementById('hideAll').addEventListener('click', () => {
    for(let i = 0; i < 9; i++) {
      const checkbox = document.getElementById(`ring${i}`);
      if(checkbox) checkbox.checked = false;
    }
    updateRingVisibility();
  });
  
  // Add incremental animation button
  const incrementalBtn = document.createElement('button');
  incrementalBtn.textContent = 'Animate Rings';
  incrementalBtn.style.marginTop = '10px';
  incrementalBtn.addEventListener('click', addRingsIncrementally);
  document.querySelector('.controls').appendChild(incrementalBtn);
  
  // Scale control
  const scaleControl = document.getElementById('scaleControl');
  if (scaleControl) {
    scaleControl.addEventListener('input', updateScale);
  }
}

// ============================================================================
// MAIN EXECUTION
// ============================================================================

if (document.readyState === 'loading') {
  document.addEventListener('DOMContentLoaded', () => {
    initFlowerOfLife();
    setupEventListeners();
  });
} else {
  initFlowerOfLife();
  setupEventListeners();
}
</script>